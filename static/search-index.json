[
  {
    "title": "intro",
    "url": "/intro",
    "content": "\n\n# Introduction\n\nWelcome to the Omnichain2 documentation. Dive into our resources to learn more about the blockchain leading the next generation of consumer crypto.\n\n## Key Design Goals\n\nOmnichain2 blockchain aims to:\n\n- Achieve consumer adoption.\n- Provide high transaction processing speed for real-world use cases.\n- Lower the cost of running blockchain applications.\n- Reduce barriers to entry for end-users.\n- Facilitate easy technology adoption for various industries.\n\n## Core Specifications\n\nOmnichain blockchain offers:\n\n- 1-second block generation and confirmation time.\n- Processing capability of 100,000 transactions per second.\n- Low gas price, approximately 1/10 of Ethereum.\n- EVM (Ethereum Virtual Machine) compatibility, supporting Solidity contracts.\n\n\n## Getting started with Omnichain2\n\nStart building smart contracts and applications on Omnichain2 with our quickstart guides.\n\nOr Watch our video tutorials to learn more about building on Omnichain2 **[youtube](https://youtube.com)**.\n\n### What you'll need\n\n- [Node.js](https://nodejs.org/en/download/) version 18.0 or above:\n  - When installing Node.js, you are recommended to check all checkboxes related to dependencies.\n- [Omnichain2 wallet](https://Omnichain2.com)\n\n\nKaia uses an optimized version of Istanbul BFT, implementing Practical Byzantine Fault Tolerance (PBFT) with blockchain-specific modifications. The consensus process involves:\n\n1. Election of a committee validatorusing Verifiable Random Function (VRF).\n2. Block generation by the elected proposer.\n3. Block verification and signing by the committee.\n\nThis enables Kaia to achieve high performance, processing 4,000 transactions per second with instant transaction finality.",
    "preview": "\n\n# Introduction\n\nWelcome to the Omnichain2 documentation. Dive into our resources to learn more about the blockchain leading the next generation of consumer crypto.\n\n## Key Design Goals\n\nOmnichain2 b..."
  },
  {
    "title": "accounts",
    "url": "/learn/accounts",
    "content": "\n# Accounts\n\n## OmnichainL2 Accounts\n\n### Overview of Account, State, and Address\n\nAn account in OmnichainL2 is a data structure containing information about a person's balance or a smart contract. OmnichainL2's state is the collection of all its accounts' states - that is, the past and current state of all data stored across OmnichainL2's accounts. When a transaction is executed on an OmnichainL2 node, the state of OmnichainL2 consequently changes across all its nodes. The state should be the same across all nodes in the OmnichainL2 network if they have processed the same blocks in the same order. State information of each account is associated with a 20-byte address, which is used to identify each account.\n\n### Decoupling Key Pairs From Addresses\n\nAn account in a typical blockchain platform is associated with a cryptographically processed address of a certain length that usually looks like this: `0x0fe2e20716753082222b52e753854f40afddffd2`. This address is strongly coupled with a key pair. If a key pair is chosen, the address is derived from the public key. This has many disadvantages in terms of user experience. Some of them are the following:\n\n- It is impossible for users to have addresses they want.\n- It is impossible for users to use multiple key pairs to increase security of their accounts.\n- It is impossible for users to change the account's key pair when the private key is accidentally exposed or when users want to update the private key periodically to increase the account's security.\n\nThose are big hurdles that users cannot think of an address as an identifier in the blockchain platform. To clear this hurdle, OmnichainL2 provides a feature that users can choose their addresses and key pairs. With this feature, users can choose addresses that they want and they can use multiple key pairs to increase security. The number of key pairs can be one or more, and the key pairs can have different roles. For details of multiple key pairs or role-based keys, please refer to Multiple Key Pairs & Role-Based Keys.\n\nIt is worth noting that OmnichainL2 also supports the old scheme that a key pair and an address are strongly coupled.\n\n### Multiple Key Pairs and Role-Based Keys\n\nAs described before, when the private key is stolen, exposed, or somehow compromised, there is nothing to do to restore the account’s security: the best option is to generate another key pair to create a new account, and migrate the balance from the old compromised account to the new one. Lack of support for advanced key schemes such as multi-sig or usage-specific key is yet another source of major inconvenience. To address those problems more efficiently, OmnichainL2 accounts provide the following capabilities:\n\n- OmnichainL2 account allows the key pair associated with the account to be changed.\n- OmnichainL2 account supports multiple key pairs, along with the ability to assign each key with different purpose.\n- OmnichainL2 account maintains compatibility with accounts having a single key that is strongly coupled with the address.\n\nBy utilizing OmnichainL2 account’s role-based multi-key support, end-users can better handle real-life security risk situations such as private key mismanagement. For example, when a user realizes that his or her private key has been exposed, the user can simply replace the compromised private key by removing the exposed key pair from his or her account and creating a new key pair to replace them. This could be achieved by using a dedicated key used for updating account information, created in advance and stored separately from the compromised private key.\n\n### OmnichainL2 Wallet Key Format\n\nOmnichainL2 wallet key format is provided to easily handle a private key along with the corresponding address. It makes it easier for a user to maintain his/her private key with an address. The format is `0x{private key}0x{type}0x{address in hex}` in hexadecimal notation, where `{type}` must be `00`. Other values are reserved. An example is shown below:\n\n```\n0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b\n```\n\n### OmnichainL2 Account Types\n\nThere are two types of accounts in OmnichainL2: externally owned accounts (EOAs) and smart contract accounts (SCAs).\n\n#### Externally Owned Accounts (EOAs)\n\nExternally owned accounts have information such as nonce and balance. This type of account does not have code or storage. EOAs are controlled by private keys and do not have code associated with them. An EOA can be created using key pairs and subsequently controlled by anyone with the key pairs. The account key is described in the section Account Key.\n\n#### Smart Contract Accounts (SCAs)\n\nIn contrast to EOAs, SCAs have code associated with them and are controlled by their code. SCAs are created by smart contract deployment transactions; once deployed, an SCA cannot initiate new transactions by itself and must be triggered by another account, either by an EOA or another SCA.\n\n### OmnichainL2 Account Type ID\n\nBelow are the Account Type IDs assigned to each Account Type.\n\n| Account Type | Account Type ID |\n|-------------|----------------|\n| Externally Owned Account (EOA) | `0x1` |\n| Smart Contract Account (SCA) | `0x2` |\n\n### Account Key\n\nAn account key represents the key structure associated with an account.\n\n#### AccountKeyNil\n\nAccountKeyNil represents an empty key. If an account tries to have an AccountKeyNil object, the transaction will fail. AccountKeyNil is used only for `TxTypeAccountUpdate` transactions with role-based keys. For example, if an account tries to update `RoleAccountUpdate` key only, the key field of the `TxTypeAccountUpdate` transaction would be:\n\n```\n[AccountKeyNil, NewKey, AccountKeyNil]\n```\n\nThen, only the `RoleAccountUpdate` key is updated. Other roles are not updated. Refer to the `AccountKeyRoleBased` for more detail.\n\n#### AccountKeyLegacy\n\nAccountKeyLegacy is used for the account having an address derived from the corresponding key pair. If an account has AccountKeyLegacy, the transaction validation process follows:\n\n1. Get the public key from `ecrecover(txhash, txsig)`.\n2. Get the address of the public key.\n3. The address is the sender.\n\n#### AccountKeyPublic\n\nAccountKeyPublic is used for accounts having one public key. If an account has an AccountKeyPublic object, the transaction validation process follows:\n\n1. Get the public key derived from `ecrecover(txhash, txsig)`.\n2. Check that the derived public key is the same as the corresponding account's public key.\n\n#### AccountKeyFail\n\nIf an account has the key `AccountKeyFail`, the transaction validation process always fails. It can be used for smart contract accounts so that a transaction...\n\n---\n\n*Note: From OmnichainL2 v1.7.0 onwards, the `vmVersion` attribute will be added to the Smart Contract Account.*\n",
    "preview": "\n# Accounts\n\n## OmnichainL2 Accounts\n\n### Overview of Account, State, and Address\n\nAn account in OmnichainL2 is a data structure containing information about a person's balance or a smart contract. Om..."
  },
  {
    "title": "architecture",
    "url": "/learn/architecture",
    "content": "\n# OmnichainL2 Architecture  \n\nAn overview of the OmnichainL2 Stack, including its blockchain, core contracts, and applications.   \n\n## Introduction to the OmnichainL2 Stack  \n\nOmnichainL2 is designed to provide the simplest possible experience for end-users, including those with no familiarity with cryptocurrencies and those using low-cost devices with limited connectivity.  \n\n### A Full-Stack Approach  \n\nTo achieve this, OmnichainL2 takes a full-stack approach, ensuring that each layer of the stack is built with the end-user in mind while also considering the needs of other stakeholders (e.g., node operators) who help enable the end-user experience.  \n\n\n## OmnichainL2 Blockchain  \n\nAn open cryptographic protocol that allows applications to process transactions and execute smart contracts in a secure and decentralized manner. The OmnichainL2 blockchain code shares ancestry with Ethereum and maintains full EVM compatibility for smart contracts. However, it uses a Byzantine Fault Tolerant (BFT) consensus mechanism (Proof-of-Stake) rather than Proof-of-Work. It also differs in block format, transaction format, client synchronization protocols, and gas payment and pricing mechanisms.  \n\n## OmnichainL2 Core Contracts  \n\nA set of smart contracts running on the OmnichainL2 blockchain that power essential platform features, including ERC-20 stable currencies, identity attestations, proof-of-stake mechanisms, and governance. These contracts are upgradeable and managed through a decentralized governance process.  \n\n\n## Applications  \n\nApplications built on the OmnichainL2 platform serve end users directly.  \n\nThe **OmnichainL2 Wallet app**, the first in an ecosystem of applications, enables users to manage accounts and make payments securely and efficiently by leveraging innovations in the OmnichainL2 Protocol.  \n\nApplications interact with the OmnichainL2 blockchain to issue transactions and invoke smart contract functions from OmnichainL2 Core Contracts. Third parties can also deploy custom smart contracts that their applications can call, integrating with OmnichainL2 Core Contracts as needed.  \n\nSome applications may use centralized cloud services to enhance user experience. For example, the OmnichainL2 Wallet employs push notifications and a transaction activity feed for better usability.  \n\nThe **OmnichainL2 blockchain and OmnichainL2 Core Contracts together form the OmnichainL2 Protocol**.  \n\n\n## OmnichainL2 Network Topology  \n\nThe OmnichainL2 network consists of machines running the OmnichainL2 blockchain software in various roles:  \n\n### **Validators**  \n\nValidators collect transactions from other nodes, execute associated smart contracts, and produce new blocks. They participate in a Byzantine Fault Tolerant (BFT) consensus mechanism to maintain network security and integrity.  \n\nSince BFT protocols scale only to a few hundred participants and can tolerate at most one-third of them acting maliciously, a proof-of-stake mechanism limits the number of validator nodes.  \n\n### **Full Nodes**  \n\nMost machines running the OmnichainL2 blockchain software operate as full nodes rather than validators. Unlike Proof-of-Work networks, OmnichainL2 nodes do not engage in \"mining.\" Instead, their primary role is to:  \n\n- Serve requests from light clients  \n- Forward transactions in exchange for transaction fees  \n\nThis system creates a **permissionless onramp** for individuals in the community to earn currency.  \n\nFull nodes maintain at least a partial history of the blockchain by transferring blocks among themselves and can join or leave the network at any time.  \n\n### **Light Clients**  \n\nApplications such as the OmnichainL2 Wallet run a **light client** version of the OmnichainL2 blockchain software on users' devices. Light clients:  \n\n- Connect to full nodes to request account and transaction data  \n- Sign and submit new transactions  \n- Do **not** store the full blockchain state  \n\n\n## **OmnichainL2 Wallet**  \n\nThe **OmnichainL2 Wallet** is a self-custody wallet that allows users to manage their funds using their own private keys and accounts. It supports:  \n\n- **Trustless transactions:** Users can send transactions and check balances without relying on a third party.  \n- **Peer-to-peer light client protocol:** This ensures security and decentralization while interacting with the blockchain.  \n\nHowever, the wallet does use some centralized cloud services to enhance user experience, including:  \n\n- **Google Play Services**: Preloads invitations within the app.  \n- **OmnichainL2 Wallet Notification Service**: Sends push notifications when a user receives a payment or payment request.  \n- **OmnichainL2 Wallet Blockchain API**: Provides a GraphQL API for querying transactions per account, used for the transaction activity feed.  \n\nWhen users download the OmnichainL2 Wallet from platforms like the Google Play Store, they trust both **cLabs (or the entity providing the app) and Google** to deliver a correct binary. Most users consider this reliance on centralized services worthwhile for improved functionality.  \n\n\nOmnichainL2 continues to evolve as an Ethereum Layer 2, ensuring scalability, accessibility, and a seamless user experience. For the latest updates, refer to the **[OmnichainL2 L2 documentation](#)**.  \n",
    "preview": "\n# OmnichainL2 Architecture  \n\nAn overview of the OmnichainL2 Stack, including its blockchain, core contracts, and applications.   \n\n## Introduction to the OmnichainL2 Stack  \n\nOmnichainL2 is designed..."
  },
  {
    "title": "consensus",
    "url": "/learn/consensus",
    "content": "\n# Consensus Mechanism\n\nA consensus mechanism (algorithm) is a way of reaching a consensus between trustless entities. In blockchain technology, it is used to determine whether a block is valid or not. The performance of blockchain networks relies heavily on the efficiency of the adopted consensus mechanisms, and it significantly impacts the perceived usability of blockchain applications.\n\n**OmnichainL2 Mainnet** exhibits the following performance metrics:\n- Handles **4,000 transactions per second**.\n- Provides **immediate transaction finality**.\n- Achieves a **one-second block generation time**.\n- Supports participation from **over 50 consensus nodes** in the consensus process.\n\nIn this document, we will explore how **OmnichainL2** implements its high-performing consensus process.\n\n---\n\n## Background\n\nBitcoin uses **Proof-of-Work (PoW)**, while Ethereum has transitioned to **Proof-of-Stake (PoS)**, where block-generating nodes are selected based on their stake. These algorithms typically involve no direct communication between nodes when determining block validity. As a result, forks can occur, meaning two or more blocks can be created at the same height. The \"longest chain wins\" rule is often applied to resolve forks, merging them into a single canonical chain over time. However, this approach lacks immediate finality, as blocks can be reverted if they belong to a shorter chain. This probabilistic finality can only be achieved after a waiting period, which still doesn't guarantee 100% certainty.\n\nThe lack of immediate finality poses challenges for customer-facing services built on blockchain platforms. For example, in financial services, a user transferring funds must wait 30 to 60 minutes to confirm the transaction's validity, as the service must ensure no forks have occurred and enough blocks have been added to the chain. This delay negatively impacts both users and service providers.\n\n---\n\n## Practical Byzantine Fault Tolerance (PBFT)\n\nTo address these issues, consensus algorithms that guarantee finality are required. The **Byzantine Fault Tolerance (BFT)** algorithm, first introduced in 1982 by Lamport, Shostak, and Pease, was later refined by Miguel Castro and Barbara Liskov in 1999 into **Practical Byzantine Fault Tolerance (PBFT)**. PBFT provides high-performance state machine replication and ensures immediate finality.\n\nUnlike PoW or PoS, where nodes validate blocks independently, PBFT requires nodes to communicate with each other to reach consensus. This communication ensures that block finality is guaranteed as soon as consensus is achieved.\n\nThe PBFT message flow involves multiple phases of communication between nodes. However, this approach has a scalability limitation: as the number of nodes increases, the communication volume grows exponentially, making it impractical for large networks.\n\n---\n\n## Consensus Mechanism in OmnichainL2\n\n**OmnichainL2** is designed to be an enterprise-ready, service-centric platform. To achieve this, it addresses the finality problem and allows a large number of nodes to participate in the network. **OmnichainL2** uses an optimized version of **Istanbul BFT**, a modified PBFT algorithm tailored for blockchain networks.\n\n### Network Architecture\nIn **OmnichainL2**, there are three types of nodes:\n1. **Consensus Nodes (CNs)**: Managed by **Core Cell Operators (CCOs)**, these nodes are responsible for block generation.\n2. **Proxy Nodes (PNs)**: Facilitate communication between CNs and other nodes.\n3. **Endpoint Nodes (ENs)**: Serve as access points for users and applications.\n\nAll nodes in the network verify blocks generated by CNs. For more details on the network topology, refer to the [Network Topology Documentation](#).\n\n### Fast Finality with Istanbul BFT\n**OmnichainL2** achieves fast finality by adopting and improving Istanbul BFT. Since validation and consensus are performed for each block, forks are eliminated, and block finality is guaranteed instantly upon consensus.\n\n### Scalability with Committee Selection\nTo address the scalability issue of PBFT, **OmnichainL2** introduces a **Committee** system. CNs collectively form a **Council**, and for each block generation, a subset of CNs is randomly selected as Committee members using a **Verifiable Random Function (VRF)**. This ensures that consensus messages are exchanged only among Committee members, limiting communication volume and enabling scalability.\n\n---\n\n## Performance and Scalability\n\nCurrently, **OmnichainL2 Mainnet** delivers:\n- A throughput of **4,000 transactions per second**.\n- A **one-second block generation interval**.\n- Support for **over 50 consensus nodes**, with plans to increase this number as the algorithm is further optimized.\n\nBy leveraging its optimized consensus mechanism, **OmnichainL2** provides a robust, scalable, and enterprise-grade blockchain platform capable of meeting the demands of modern decentralized applications.",
    "preview": "\n# Consensus Mechanism\n\nA consensus mechanism (algorithm) is a way of reaching a consensus between trustless entities. In blockchain technology, it is used to determine whether a block is valid or not..."
  },
  {
    "title": "tokenomics",
    "url": "/learn/tokenomics",
    "content": "\n# Tokenomics\n\n## Overview\nOmnichainL2’s token economy is designed to create sustainable funding structures for empowering its ecosystem, growth initiatives, and strategic investments. Many public blockchain projects have monetary systems that solely incentivize their node operators (miners or block producers), focusing only on the technical aspect of network maintenance. However, such designs miss out on the importance of incentivizing other types of participants who contribute to the growth of the network’s token economy or invest in long-term growth prospects. In contrast, OmnichainL2’s token economy is designed to compensate more diverse forms of contributions from a wider range of participants and has a built-in funding structure to procure sustained resources to fuel future growth initiatives and strategically sourced investment projects in addition to maintaining its blockchain nodes.\n\n## Funding Structure\nOmnichainL2’s funding structure runs continuously with OmnichainL2 network’s block generation. With every new block, newly issued OMNICH and the sum of transaction fees used in the block (collectively called “block reward”) are aggregated and distributed to the following three destination accounts in accordance to the predetermined ratio:\n\n- **Validators and Community:** 50%\n  - Block proposer rewards: 20% of the 50% (10% of total)\n  - Staking rewards: 80% of the 50% (40% of total)\n- **OmnichainL2 Ecosystem Fund (OEF):** 25%\n- **OmnichainL2 Infrastructure Fund (OIF):** 25%\n\n9.6 OMNICH will be minted for every new block. This implies that approximately 300 million OMNICH will be minted annually, which is equivalent to 5.2% annual inflation against the total OMNICH tokens in the market (the annual inflation rate is subject to change through the OmnichainL2 Governance Process). Transaction fees are charged and metered according to the pre-determined fee tables. For detailed information about the transaction fees, please refer to Transaction Fees.\n\n## OmnichainL2 Governance Council Reward\nThe OmnichainL2 Governance Council is the collective group of Core Cell Operators (CCOs). Council members are responsible for maintaining Core Cells (CCs), which makes the Council an essential body in the OmnichainL2 ecosystem responsible for providing the underlying infrastructure. To become a Council member, the candidate must undergo a qualification review by the OmnichainL2 Governance Process and must stake at least 5 million OMNICH. The OmnichainL2 Governance Council Reward is a structure for incentivizing Council members to continue to provide a stable foundation for the OmnichainL2 ecosystem.\n\n### OmnichainL2 Governance Council Reward Mechanism\nFor each block in the OmnichainL2 blockchain, a Committee is formed by randomly selecting members from the OmnichainL2 Governance Council (GC). This Committee consists of a single member who is assigned the role of Proposer, while the remaining Committee members take on the role of Validators. Once a block is successfully created and appended to the OmnichainL2 blockchain, the block reward is distributed among the Council members and various funds according to the previously mentioned ratios.\n\nAll Council members have an equal probability of being selected as the Proposer for a given block, and the block proposer reward is distributed evenly among them. However, the GC staking reward is allocated proportionally based on the amount of OMNICH staked by each member, minus the minimum requirement of 5 million OMNICH. This means that Council members who stake a larger amount of OMNICH beyond the minimum threshold will receive a greater share of the staking reward compared to those who stake less. As a result, Council members are incentivized to stake more OMNICH to maximize their potential rewards from the GC staking award portion of the block reward distribution.\n\nAs long as the minimum 5 million OMNICH staking requirement is met, OmnichainL2 Governance Council members can freely stake or unstake their OMNICH. Staking information is updated every 86,400 blocks, and newly staked OMNICH comes into effect two update cycles later from when the staking is completed. Withdrawing staked OMNICH requires one week of delay to prevent malicious members from immediately exiting.\n\n### Penalty for Misbehaving Council Members\nA Council member may be subject to penalties for conducting misbehaviors defined below. In the future, more penalty rules can be established and refined through the OmnichainL2 Governance Process.\n\n- **Causing Safety Failure:**\n  - A Council member selected as Proposer may not create more than one block at the same height.\n  - A Council member selected as Proposer may not intentionally omit certain transactions.\n- **Causing Liveness Failure:**\n  - A Council member selected as Proposer must create a valid block.\n  - A Council member selected as Validator must validate the block proposed by the Proposer.\n\n## OmnichainL2 Ecosystem Fund\nThe OmnichainL2 Ecosystem Fund (OEF) was established to support OmnichainL2's mission of enabling greater transparency and verifiability. It is funded by 25% of the total OMNICH issued when creating a block.\n\nThe OmnichainL2 Ecosystem Fund will be used to fund activities that improve the OmnichainL2 ecosystem, such as:\n\n- **Service Contribution Reward (SCR):** The OEF will provide rewards to service developers or users operating on the integrated ecosystem, as compensation for directly or indirectly contributing to the enhancement of the ecosystem's value.\n- **Building our Developer Community:** The OEF will support various initiatives including hackathons, development education programs, collaborative research with academia, and collaboration with various DAOs to foster and grow the OmnichainL2 developer community.\n- **Fostering Ecosystem Services and Infrastructure:** The OEF will support essential ecosystem infrastructure, alongside the development of services with clear utility and provide marketing support.\n- **OmnichainL2 Eco Fund Indirect Investment:** The OEF will make indirect mid-to-long-term investments by entrusting specialized crypto VCs. A portion of the profits generated upon subsequent investment recovery will be either burned or returned to the OmnichainL2 ecosystem.\n- **Governance Committee Budget:** This budget is allocated for the operation of committees in specific sectors such as Gaming, DeFi, and Community. These committees aim to grow the OmnichainL2 Blockchain ecosystem in their respective sectors.\n- **Other ecosystem and community-building activities.**\n\nThe administration of the OmnichainL2 Ecosystem Fund follows a process in which the Governance Council (GC) reviews and approves the use of funds in public forums on OmnichainL2 Square. The Foundation will submit a quarterly budget proposal for each category to the GC for approval. Within the approved budget, each specific use will be reviewed and approved again by the GC. All execution details are transparently disclosed.\n\nNew proposals for the use of OEF can be made via the GC, requiring individual approval. Plans are in place to develop a structure allowing more ecosystem participants to efficiently propose and participate in OEF use. For categories requiring specialized and rapid decision-making, separate governance committees may operate.\n\n## OmnichainL2 Infrastructure Fund\nOmnichainL2 Infrastructure Fund (OIF) is an operational fund that will focus on these main categories:\n\n- **Mainnet and Essential Infrastructure R&D:** This includes advancing research on the latest technologies related to mainnet and infrastructure, foundation-led service development, and infrastructure establishment.\n- **Ecosystem Acceleration:** This includes token swap, financial support for small-scale OmnichainL2 Blockchain ecosystem partners, attracting new GC members, and providing market liquidity.\n- **Foundation Operations:** This includes operating expenses such as development, accounting, legal affairs, IT infrastructure operations, marketing, and labor costs, as well as financial management and fundraising costs.\n\nOIF is funded by 25% of the total OMNICH issued when creating a block. It is executed by the foundation through an internal control system after a prior announcement of the budget plan for each detailed category. All execution details are transparently disclosed.\n\nThe foundation directly establishes a budget plan and executes the funds for OIF. To ensure transparent execution, the foundation discloses the budget plans and execution details in advance and afterward.\n\n## Treasury Rebalancing\nTo ensure the flexibility and adaptability of OmnichainL2's token economy, a Treasury Rebalance mechanism has been implemented. This process allows for adjustments to the treasury funds in response to changing ecosystem needs and market conditions.\n\n### Treasury Rebalance Contract\nThe Treasury Rebalance Contract is a smart contract designed to manage the rebalancing process in a transparent and secure manner. At its core, the contract operates as a finite state machine, progressing through stages such as initialization, registration, approval, and finalization. This structured approach ensures that all stakeholders have the opportunity to review and approve changes before they are implemented.\n\nKey features of this contract include:\n\n- **Flexible Balance Adjustment:** The contract supports both increases and decreases in total fund balance, enabling comprehensive treasury management.\n- **Aligned Rebalance Timing:** The rebalance block number can be set to align with relevant hard fork block numbers, providing better synchronization with network upgrades.\n- **Transparent Execution:** The entire rebalancing process is recorded on the blockchain through the TreasuryRebalance contract, maintaining the ecosystem's commitment to openness and verifiability.\n- **Validator Consensus:** The rebalance event occurs only after reaching consensus among block validators, ensuring network-wide agreement on the changes.\n- **Immutable Record:** After execution, a detailed memo of the rebalance event is uploaded to the contract, providing an immutable record of the changes for future reference and auditing.\n\nThis Treasury Rebalancing mechanism allows OmnichainL2 to maintain a dynamic and responsive token economy, better serving the evolving needs of its ecosystem while upholding principles of transparency and security. By leveraging smart contract technology and a consensus-based approach, it provides a structured and verifiable way to adjust treasury funds, ensuring that the OmnichainL2 blockchain can adapt to changing circumstances while maintaining the trust of its community.\n",
    "preview": "\n# Tokenomics\n\n## Overview\nOmnichainL2’s token economy is designed to create sustainable funding structures for empowering its ecosystem, growth initiatives, and strategic investments. Many public blo..."
  },
  {
    "title": "transactions",
    "url": "/learn/transactions",
    "content": "\n# Transactions\n\nTransactions are the core mechanism for state changes on the **OmnichainL2** blockchain. They represent messages passed between accounts, altering balances, deploying smart contracts, or executing contract functions. For example, when a transaction that sends 10 **OMNI** from Alice’s account to Bob’s is executed, Alice's balance decreases by 10 **OMNI**, and Bob's balance increases by 10 **OMNI**. Understanding transactions is fundamental to grasping how **OmnichainL2** works.\n\n## Key Aspects of OmnichainL2 Transactions\n\n### Atomic Operations\nEach transaction is treated as a single, indivisible unit. Either the entire transaction succeeds, applying all changes, or it fails, leaving the blockchain state unchanged. This ensures data integrity and prevents partial updates.\n\n### Components\n**OmnichainL2** transactions share core components with other blockchains but also have unique elements due to its decoupling of key pairs and addresses. This decoupling enhances flexibility but requires explicit sender information within the transaction. Typical components include:\n\n- **Sender**: The originating account (`from` field). This is explicitly included in **OmnichainL2** transactions because addresses and key pairs are not directly linked.\n- **Recipient**: The destination account (`to` field, for value transfers and smart contract interactions).\n- **Value**: The amount of **OMNI** being transferred (`value` field, in **wei**).\n- **Data**: Additional information (`input` field), often used as input for smart contract execution.\n- **Fees**: Calculated based on `gas` (maximum gas allowed) * `gasPrice` (price per unit of gas). Fees are paid in **OMNI** (unit: **wei**, see [link to OMNI units documentation]).\n- **Signature** (`v`, `r`, `s` fields): Cryptographic proof authorizing the transaction.\n\n### Transaction Types\n**OmnichainL2** offers a variety of transaction types to support different use cases, from basic value transfers to complex smart contract interactions and fee delegation. This flexibility caters to diverse needs and optimizes performance. See the [Implementing Transactions](#) page for details on each type.\n\n### Fee Mechanism\nTransactions require fees to incentivize validators. These fees are calculated based on the computational resources consumed (`gas`) and a price per unit of gas (`gasPrice`), which can be dynamic.\n\n### Security\nTransactions are cryptographically signed, ensuring authenticity and preventing unauthorized modifications. **OmnichainL2**'s decoupling of key pairs and addresses adds another layer of security.\n\n### Fee Delegation\n**OmnichainL2**'s fee delegation feature allows third parties to pay transaction fees on behalf of users, simplifying user onboarding and supporting various business models. This requires two signatures: one from the sender and one from the fee payer. See the [Fee Delegation](#) for its implementation details.\n\n---\n\nThis conceptual overview provides a foundation for understanding **OmnichainL2** transactions. The [Implementing Transactions](#) offers a detailed guide for developers.",
    "preview": "\n# Transactions\n\nTransactions are the core mechanism for state changes on the **OmnichainL2** blockchain. They represent messages passed between accounts, altering balances, deploying smart contracts,..."
  },
  {
    "title": "why-omni",
    "url": "/learn/why-omni",
    "content": "\n# Discover Omnil2  \n\nOmnil2 is a blockchain network designed for the real world, with a mission to build a regenerative digital economy that fosters prosperity for all.  \n\n## What is Omnil2?  \n\nOmnil2 is an emerging Ethereum Layer-2 designed to make blockchain technology accessible to all. With its focus on scalability, low fees, and ease of use, Omnil2 is ideal for building blockchain products that reach millions of users around the globe.  \n\n## Why Build on Omnil2?  \n\nOmnil2 is fully EVM-compatible, offering the same development experience as Ethereum with improved scalability and lower costs.  \n\n### Built for Everyday Users  \n\nOmnil2 is designed with features that lower the entry barrier for those new to cryptocurrency.  \n\n- **Fee Abstraction**: Users can pay transaction fees with several different tokens, making payments simple and flexible.  \n- **Sub-Cent Fees**: Omnil2 maintains low gas fees, often below a cent, keeping transactions affordable.  \n- **Native Stablecoins**: Omnil2 provides native stablecoins like oUSD, oEUR, oREAL, and oKES, offering a stable way to send and receive money. Check out [Mento](https://mento.org/) to learn more.  \n\n### Mobile-First Approach  \n\nOmnil2 is optimized for mobile devices, making blockchain accessible to billions of smartphone users worldwide.  \n\n- **Phone Number Mapping**: Omnil2’s native protocol, **Social Connect**, links wallets to phone numbers, making it easy to send and receive payments using just a phone number.  \n\n### Optimized for Global Reach  \n\n- **Scalability**: Omnil2’s focus on real-world use cases has already helped scale applications to over **100,000 daily active users (DAUs)**, proving its capability to support large-scale deployment.  \n- **Community Engagement**: Omnil2 boasts an active global community of users and builders. With over **4 years** of experience in bringing blockchain to real-world users, Omnil2 offers a supportive environment for developers to test, launch, and scale their applications.  \n\n  Community members are engaged and eager to provide feedback, helping builders refine their products for broad, practical use. If you are interested in contributing, make sure to reach out.  \n\n### Carbon Negative  \n\nOmnil2 is committed to environmental sustainability, offsetting more carbon than it produces.  \n\n- **Proof-of-Stake**: Omnil2 uses an energy-efficient consensus mechanism that avoids energy-intensive mining, reducing its carbon footprint.  \n- **Ultragreen Money**: A portion of every transaction fee goes towards carbon offsetting and sustainability projects, supporting environmental efforts with every transaction.  \n\n## Understanding the Omnil2 Ecosystem  \n\n### What is OMNI?  \n\nOMNI is the platform-native asset that supports the growth and development of the Omnil2 blockchain and ecosystem. OMNI holders can earn rewards, stake with validators, and vote on proposals that shape the future of Omnil2.  \n\n### What Makes Omnil2's Native Stablecoins Unique?  \n\nNamed for the currencies they follow, **Omnil2 Dollars (oUSD), Omnil2 Euros (oEUR), Omnil2 Reals (oREAL), and Omnil2 Kenyan Shilling (oKES)** are **Mento stablecoins** that allow you to share value faster, cheaper, and more easily on your mobile phone.  \n\nMento stablecoins instantly unlock access for everyday uses like:  \n\n- **Low-cost remittances and cross-border payments**  \n- **Global distribution of charitable aid**  \n- **Effortlessly paying online**  \n- **Transferring value within exchanges**, particularly in markets subject to currency volatility  \n\n## Get Started with Omnil2  \n\nWhether you're an experienced developer or just starting out, Omnil2 provides the essential tools and resources to turn your ideas into reality.  \n\nStart building on Omnil2 today and contribute to a growing ecosystem that supports a **regenerative digital economy**, fostering prosperity for all.  \n\nConnect with us on [Discord](https://discord.gg/omnil2) or on [X](https://twitter.com/Omnil2), and be sure to explore our [ecosystem resources](https://omnil2.org/).  \n",
    "preview": "\n# Discover Omnil2  \n\nOmnil2 is a blockchain network designed for the real world, with a mission to build a regenerative digital economy that fosters prosperity for all.  \n\n## What is Omnil2?  \n\nOmnil..."
  },
  {
    "title": "components",
    "url": "/nodes/components",
    "content": "\n# Components\n\nLearn the components of an Omnichainl2 node and how they work together.\n\nThis section contains an overview of the Omnichainl2 node’s main components.\n\n## API\n\nThe Omnichainl2 node can serve both the HTTP and the WS Web3 API, as well as PubSub. Whenever possible, it provides data based on the local state, with a few exceptions:\n\n- **Submitting transactions**: Since it is a read replica, submitted transactions are proxied to the main node, and the response is returned from the main node.\n- **Querying transactions**: The Omnichainl2 node is not aware of the main node’s mempool, and it does not sync rejected transactions. Therefore, if a local lookup for a transaction or its receipt fails, the Omnichainl2 node will attempt the same query on the main node.\n\nApart from these cases, the API does not depend on the main node. Even if the main node is temporarily unavailable, the Omnichainl2 node can continue to serve the state it has locally.\n\n## Fetcher\n\nThe Fetcher component is responsible for maintaining synchronization between the Omnichainl2 node and the main node. Its primary task is to fetch new blocks in order to update the local chain state. However, its responsibilities extend beyond that. For instance, the Fetcher is also responsible for keeping track of L1 batch statuses. This involves monitoring whether locally applied batches have been committed, proven, or executed on L1.\n\nIt is worth noting that in addition to fetching the state, the Omnichainl2 node also retrieves the L1 gas price from the main node for the purpose of estimating fees for L2 transactions (since this also happens based on the local state). This information is necessary to ensure that gas estimations are performed in the exact same manner as the main node, thereby reducing the chances of a transaction not being included in a block.\n\n## State Keeper / VM\n\nThe State Keeper component serves as the “sequencer” part of the node. It shares most of its functionality with the main node, with one key distinction. The main node retrieves transactions from the mempool and has the authority to decide when a specific L2 block or L1 batch should be sealed. On the other hand, the Omnichainl2 node retrieves transactions from the queue populated by the Fetcher and seals the corresponding blocks/batches based on the data obtained from the Fetcher queue.\n\nThe actual execution of batches takes place within the VM, which is identical in any Omnichainl2 node.\n\n## Reorg Detector\n\nIn Omnichainl2, it is theoretically possible for L1 batches to be reverted before the corresponding “execute” operation is applied on L1, that is, before the block is final. Such situations are highly uncommon and typically occur due to significant issues, e.g., a bug in the sequencer implementation preventing L1 batch commitment. Prior to batch finality, the Omnichainl2 operator can perform a rollback, reverting one or more batches and restoring the blockchain state to a previous point. Finalized batches cannot be reverted at all.\n\nHowever, even though such situations are rare, the Omnichainl2 node must handle them correctly.\n\nTo address this, the Omnichainl2 node incorporates a Reorg Detector component. This module keeps track of all L1 batches that have not yet been finalized. It compares the locally obtained state root hashes with those provided by the main node’s API. If the root hashes for the latest available L1 batch do not match, the Reorg Detector searches for the specific L1 batch responsible for the divergence. Subsequently, it rolls back the local state and restarts the node. Upon restart, the Omnichainl2 node resumes normal operation.\n\n## Consistency Checker\n\nThe main node API serves as the primary source of information for the Omnichainl2 node. However, relying solely on the API may not provide sufficient security since the API data could potentially be incorrect due to various reasons. The primary source of truth for the rollup system is the L1 smart contract. Therefore, to enhance the security of the Omnichainl2 node, each L1 batch undergoes cross-checking against the L1 smart contract by a component called the Consistency Checker.\n\nWhen the Consistency Checker detects that a particular batch has been sent to L1, it recalculates a portion of the input known as the “block commitment” for the L1 transaction. The block commitment contains crucial data such as the state root and batch number, and is the same commitment that is used for generating a proof for the batch. The Consistency Checker then compares the locally obtained commitment with the actual commitment sent to L1. If the data does not match, it indicates a potential bug in either the main node or Omnichainl2 node implementation or that the main node API has provided incorrect data. In either case, the state of the Omnichainl2 node cannot be trusted, and the Omnichainl2 node enters a crash loop until the issue is resolved.\n\n## Health Check Server\n\nThe Omnichainl2 node also exposes an additional server that returns HTTP 200 response when the Omnichainl2 node is operating normally, and HTTP 503 response when some of the health checks don’t pass (e.g., when the Omnichainl2 node is not fully initialized yet). This server can be used, for example, to implement the readiness probe in an orchestration solution you use.\n",
    "preview": "\n# Components\n\nLearn the components of an Omnichainl2 node and how they work together.\n\nThis section contains an overview of the Omnichainl2 node’s main components.\n\n## API\n\nThe Omnichainl2 node can s..."
  },
  {
    "title": "introduction",
    "url": "/nodes/introduction",
    "content": "\n# Introduction\n\nLearn how OmnichainL2 Nodes work at a high level.\n\nThis documentation explains the basics of the OmnichainL2 node. The contents of this section were heavily inspired by zkSync’s node running docs.\n\n### Disclaimers\n\n- The OmnichainL2 node software is provided “as-is” without any express or implied warranties.\n- The OmnichainL2 node is in the beta phase and should be used with caution.\n- The OmnichainL2 node is a read-only replica of the main node.\n- The OmnichainL2 node will not serve as the consensus node.\n- Running a sequencer node is currently not possible, and there is no option to vote on blocks as part of the consensus mechanism or fork-choice like on Ethereum.\n\n### What is the OmnichainL2 Node?\n\nThe OmnichainL2 node is a read-replica of the main (centralized) node that can be run by anyone. It functions by fetching data from the OmnichainL2 API and re-applying transactions locally, starting from the genesis block. The OmnichainL2 node shares most of its codebase with the main node. Consequently, when it re-applies transactions, it does so exactly as the main node did in the past.\n\nIn Ethereum terms, the current state of the OmnichainL2 Node represents an archive node, providing access to the entire history of the blockchain.\n\n### High-level Overview\n\nAt a high level, the OmnichainL2 Node can be seen as an application that has the following modules:\n\n- API server that provides the publicly available Web3 interface.\n- Synchronization layer that interacts with the main node and retrieves transactions and blocks to re-execute.\n- Sequencer component that executes and persists transactions received from the synchronization layer.\n- Several checker modules that ensure the consistency of the OmnichainL2 Node state.\n\nWith the OmnichainL2 Node, you are able to:\n\n- Locally recreate and verify the OmnichainL2 mainnet/testnet state.\n- Interact with the recreated state in a trustless way (in the sense that the validity is locally verified, and you should not rely on a third-party API provided by OmnichainL2).\n- Use the Web3 API without having to query the main node.\n- Send L2 transactions (that will be proxied to the main node).\n\nWith the OmnichainL2 Node, you cannot:\n\n- Create L2 blocks or L1 batches on your own.\n- Generate proofs.\n- Submit data to L1.\n\nA more detailed overview of the OmnichainL2 Node’s components is provided in the components section.\n\n### API Overview\n\nThe API exposed by the OmnichainL2 Node strives to be Web3-compliant. If any method is exposed but behaves differently compared to Ethereum, it should be considered a bug. Please report such cases.\n\n### `eth_` Namespace\n\nData getters in this namespace operate in the L2 space: require/return L2 block numbers, check balances in L2, etc.\n\n#### Available methods:\n\n| Method                                       | Notes                                                                 |\n|----------------------------------------------|-----------------------------------------------------------------------|\n| eth_blockNumber                              |                                                                       |\n| eth_chainId                                  |                                                                       |\n| eth_call                                     |                                                                       |\n| eth_estimateGas                              |                                                                       |\n| eth_gasPrice                                 |                                                                       |\n| eth_newFilter                                | Maximum amount of installed filters is configurable                   |\n| eth_newBlockFilter                           | Same as above                                                        |\n| eth_newPendingTransactionsFilter             | Same as above                                                        |\n| eth_uninstallFilter                          |                                                                       |\n| eth_getLogs                                   | Maximum amount of returned entities can be configured                |\n| eth_getFilterLogs                            | Same as above                                                        |\n| eth_getFilterChanges                         | Same as above                                                        |\n| eth_getBalance                               |                                                                       |\n| eth_getBlockByNumber                         |                                                                       |\n| eth_getBlockByHash                           |                                                                       |\n| eth_getBlockTransactionCountByNumber         |                                                                       |\n| eth_getBlockTransactionCountByHash           |                                                                       |\n| eth_getCode                                  |                                                                       |\n| eth_getStorageAt                             |                                                                       |\n| eth_getTransactionCount                      |                                                                       |\n| eth_getTransactionByHash                     |                                                                       |\n| eth_getTransactionByBlockHashAndIndex        |                                                                       |\n| eth_getTransactionByBlockNumberAndIndex      |                                                                       |\n| eth_getTransactionReceipt                    |                                                                       |\n| eth_protocolVersion                          |                                                                       |\n| eth_sendRawTransaction                       |                                                                       |\n| eth_syncing                                  | OmnichainL2 is considered synced if it’s less than 11 blocks behind the main node |\n| eth_coinbase                                 | Always returns a zero address                                        |\n| eth_accounts                                 | Always returns an empty list                                         |\n| eth_getCompilers                             | Always returns an empty list                                         |\n| eth_hashrate                                 | Always returns zero                                                  |\n| eth_getUncleCountByBlockHash                 | Always returns zero                                                  |\n| eth_getUncleCountByBlockNumber               | Always returns zero                                                  |\n| eth_mining                                   | Always returns false                                                 |\n\n### PubSub\n\nOnly available on the WebSocket servers.\n\n#### Available methods:\n\n| Method              | Notes                                                     |\n|---------------------|-----------------------------------------------------------|\n| eth_subscribe       | Maximum amount of subscriptions is configurable          |\n| eth_subscription    |                                                           |\n\n### `net_` Namespace\n\n#### Available methods:\n\n| Method             | Notes                                                     |\n|--------------------|-----------------------------------------------------------|\n| net_version        |                                                           |\n| net_peer_count     | Always returns 0                                           |\n| net_listening      | Always returns false                                       |\n\n### `web3_` Namespace\n\n#### Available methods:\n\n| Method             | Notes                                                     |\n|--------------------|-----------------------------------------------------------|\n| web3_clientVersion |                                                           |\n\n### `debug` namespace\n\nThe `debug` namespace gives access to several non-standard RPC methods, which will allow developers to inspect and debug calls and transactions.\n\nThis namespace is disabled by default and can be configured via setting `EN_API_NAMESPACES` as described in the example config.\n\n#### Available methods:\n\n| Method                         | Notes |\n|--------------------------------|-------|\n| debug_traceBlockByNumber       |       |\n| debug_traceBlockByHash         |       |\n| debug_traceCall                |       |\n| debug_traceTransaction         |       |\n\n### `omnichainl2` namespace\n\nThis namespace contains rollup-specific extensions to the Web3 API. Note that only methods specified in the documentation are considered public. There may be other methods exposed in this namespace, but undocumented methods come without any kind of stability guarantees and can be changed or removed without notice.\n\nAlways refer to the documentation linked above and API reference documentation to see the list of stabilized methods in this namespace.\n\n### `en` namespace\n\nThis namespace contains methods that OmnichainL2 Nodes call on the main node while syncing. If this namespace is enabled, other OmnichainL2 Nodes can sync from this node.\n",
    "preview": "\n# Introduction\n\nLearn how OmnichainL2 Nodes work at a high level.\n\nThis documentation explains the basics of the OmnichainL2 node. The contents of this section were heavily inspired by zkSync’s node ..."
  },
  {
    "title": "run-node",
    "url": "/nodes/run-node",
    "content": "\n# Running a Node\nLearn how to run your own **Omnichain** node.\n\n\n## Prerequisites\n##### Installations Required:\n- Docker\n- Docker Compose\n\n\n## Setup Instructions\n\nClone the **Omnichain** node repository and navigate to `external-node/`:\n\n   ```bash\n   git clone https://github.com/Omnichain-Foundation/omnichain-node\n   cd omnichain-node/external-node```\n\n## Running an Abstract Node Locally\n​\n### Starting the Node\n ```bash\ndocker compose --file testnet-external-node.yml up -d\n```\n### Reading Logs\n\n ```bash\ndocker compose --file testnet-external-node.yml up -d\n```\n\nContainer name options:\n\n- testnet-node-external-node-1\n- testnet-node-postgres-1\n- testnet-node-prometheus-1\n- testnet-node-grafana-1\n\n### Resetting the Node State\n\n```bash\ndocker compose --file testnet-external-node.yml down --volumes\n```\n\n## Important Notes\n\n- **Initial Recovery**: The node will recover from genesis (until we set up a snapshot) on its first run, which may take some time. During this period, the API server will not serve any requests.\n- **Historical Data**: For access to historical transaction data, consider recovery from DB dumps. Refer to the Advanced Setup section for more details.\n- **DB Dump**: For nodes that operate from a DB dump, which allows starting an Abstract node with a full historical transaction history, refer to the documentation on running from DB dumps at `03_running.md`.\n\n## System Requirements\n\nThe following are minimal requirements:\n\n- **CPU**: A relatively modern CPU is recommended.\n- **RAM**: 32 GB\n- **Storage**:\n  - Testnet Nodes: 30 GB\n  - Mainnet Nodes: 300 GB, with the state growing about 1TB per month.\n- **Network**: 100 Mbps connection (1 Gbps+ recommended)\n\n## Advanced Setup\n\nFor additional configurations like monitoring, backups, recovery from DB dump or snapshot, and custom PostgreSQL settings, please refer to the `ansible-en-role` repository.\n\n",
    "preview": "\n# Running a Node\nLearn how to run your own **Omnichain** node.\n\n\n## Prerequisites\n##### Installations Required:\n- Docker\n- Docker Compose\n\n\n## Setup Instructions\n\nClone the **Omnichain** node reposit..."
  },
  {
    "title": "blockexp",
    "url": "/tooling/blockexp",
    "content": "\n# Block Explorers\n\nLearn how to view transactions, blocks, batches, and more on Abstract block explorers.\n\nThe block explorer allows you to:\n\n- View, verify, and interact with smart contract source code.\n- View transaction, block, and batch information.\n- Track the finality status of transactions as they reach Ethereum.\n\n\n### Try our available explorers:\n\n- [Mainnet explorer](https://mainnet.example.com)\n- [Testnet explorer](https://testnet.example.com)\n\n\n\n",
    "preview": "\n# Block Explorers\n\nLearn how to view transactions, blocks, batches, and more on Abstract block explorers.\n\nThe block explorer allows you to:\n\n- View, verify, and interact with smart contract source c..."
  },
  {
    "title": "bridges",
    "url": "/tooling/bridges",
    "content": "\n# Bridges\n\nLearn how to bridge assets between Abstract and Ethereum.\n\nA bridge is a tool that allows users to move assets such as ETH from Ethereum to Abstract and vice versa. Under the hood, bridging works by having two smart contracts deployed:\n\n- A smart contract deployed to Ethereum (L1).\n- A smart contract deployed to Abstract (L2).\n\nThese smart contracts communicate with each other to facilitate the deposit and withdrawal of assets between the two chains.\n\n### Native Bridge\n\nAbstract has a native bridge to move assets between Ethereum and Abstract for free (excluding gas fees) that supports bridging both ETH and ERC-20 tokens.\n\n- Deposits from L1 to L2 take around ~15 minutes.\n- Withdrawals from L2 to L1 currently take up to 24 hours due to the built-in withdrawal delay.\n\n### Try our available bridges:\n\n- [Mainnet bridge](https://mainnet-bridge.example.com)\n- [Testnet bridge](https://testnet-bridge.example.com)\n",
    "preview": "\n# Bridges\n\nLearn how to bridge assets between Abstract and Ethereum.\n\nA bridge is a tool that allows users to move assets such as ETH from Ethereum to Abstract and vice versa. Under the hood, bridgin..."
  },
  {
    "title": "faucets",
    "url": "/tooling/faucets",
    "content": "\n# Faucets\n\nLearn how to easily get testnet funds for development on Omnichain blockchain.\n\nFaucets distribute small amounts of testnet ETH to enable developers & users to deploy and interact with smart contracts on the testnet.\n\nOmnichain blockchain has its own testnet that uses the Sepolia network as the L1, meaning you can get testnet ETH on Omnichain blockchain directly or bridge Sepolia ETH to the Omnichain testnet.\n\n### Omnichain Testnet Faucets\n\n| Name                 | Requires Signup |\n|----------------------|-----------------|\n| Triangle faucet      | No              |\n| Thirdweb faucet      | Yes             |\n\n### L1 Sepolia Faucets\n\n| Name                                 | Requires Signup | Requirements                 |\n|--------------------------------------|-----------------|------------------------------|\n| Ethereum Ecosystem Sepolia PoW faucet| No              | ENS Handle                   |\n| Sepolia PoW faucet                  | No              | Gitcoin Passport score       |\n| Google Cloud Sepolia faucet         | No              | 0.001 mainnet ETH            |\n| Grabteeth Sepolia faucet            | No              | A smart contract deployment before 2023 |\n| Infura Sepolia faucet               | Yes             | -                            |\n| Chainstack Sepolia faucet           | Yes             | -                            |\n| Alchemy Sepolia faucet              | Yes             | 0.001 mainnet ETH            |\n\nUse a bridge to move Sepolia ETH to the Omnichain testnet.\n",
    "preview": "\n# Faucets\n\nLearn how to easily get testnet funds for development on Omnichain blockchain.\n\nFaucets distribute small amounts of testnet ETH to enable developers & users to deploy and interact with sma..."
  },
  {
    "title": "create-accounts",
    "url": "/tutorial-basics/create-accounts",
    "content": "\n# Create Accounts\n\n## Creating a New Account <a id=\"creating-a-new-account\"></a>\n\nThis will create a new account and print the address on the screen. A keystore file is created under the data directory.\n\n**Kaia Keystore File**\n\nWhen you create an account, a keystore file is created. The keystore file is an encrypted version of your unique Kaia private key that you will use to sign your transactions. The keystore file name has the following format:\n\n* `UTC--<created_at UTC ISO8601>-<address hex>`\n\nIt is safe to transfer the entire directory or the individual keystore file therein between Kaia nodes. Note that in case you are adding keys to your node from a different node, the order of accounts may change. So make sure you do not rely on the index in your scripts or code snippets.\n\n### ken <a id=\"ken\"></a>\n\n```bash\n$ ken account new --datadir <DATADIR>\n$ ken account new --password <passwordfile> --datadir <DATADIR>\n$ ken account new --password <(echo $mypassword) --datadir <DATADIR>\n```\n\n**`WARNING`**: Note that using a password file is meant for testing only; it is a bad idea to save your password in a file or expose it in any other way. If you use the password flag with a password file, best to make sure the file is not readable or even listable for anyone but you. You achieve this with:\n\n```bash\n$ touch /path/to/password\n$ chmod 700 /path/to/password\n$ cat > /path/to/password\nI type my pass here\n^D\n```\n\n### JavaScript Console <a id=\"javascript-console\"></a>\n\nOn the console, you can call the following function to create an account:\n\n```javascript\n> personal.newAccount(\"passphrase\")\n```\n\nThe account is saved in an encrypted format. You **must** remember this passphrase to unlock your account in the future.\n\n## Importing an Account <a id=\"importing-an-account\"></a>\n\nYou can import an account using a keyfile. The keyfile is assumed to contain an unencrypted private key as canonical EC raw bytes encoded into hex. In simpler terms, it is a private key in plain text without the leading `0x`.\n\nThis imports an unencrypted private key from the given keyfile, creates a new account, generates a keystore file under the data directory, and prints the address in the console. You must remember the passphrase to unlock your account in the future.\n\n**NOTE**: If you can directly copy your keystore files to another Kaia instance, this import/export mechanism is not needed.\n\n### ken <a id=\"ken-1\"></a>\n\n```bash\n$ ken account import --datadir <datadir> <keyfile>\n$ ken account import --password <passwordfile> --datadir <datadir> <keyfile>\n```\n\n### JavaScript Console <a id=\"javascript-console-1\"></a>\n\n```bash\n> personal.importRawKey('{private key}', 'mypassword')\n\"0xfa415bb3e6231f488ff39eb2897db0ef3636dd32\"​\n\n// Using a Kaia wallet key\n> personal.importRawKey('{private key}0x000x{address}', 'mypassword')\n\"0xfa415bb3e6231f488ff39eb2897db0ef3636dd32\"\n```",
    "preview": "\n# Create Accounts\n\n## Creating a New Account <a id=\"creating-a-new-account\"></a>\n\nThis will create a new account and print the address on the screen. A keystore file is created under the data directo..."
  },
  {
    "title": "deploy",
    "url": "/tutorial-basics/deploy",
    "content": "\n# Your First Smart Contract\n\nTokenizing real estate on the Omnichain blockchain allows fractional ownership, seamless transfer of assets, and improved transparency. In this guide, we'll create a smart contract for tokenized real estate using Solidity and deploy it on Omnichain.\n\n### Prerequisites\n\n1. **Set Up Development Environment**:\n    - Install [Node.js](https://nodejs.org/).\n    - Install [Hardhat](https://hardhat.org/):\n      ```bash\n      npm install --save-dev hardhat\n      ```\n\n2. **Install Dependencies**:\n    ```bash\n    npm install @openzeppelin/contracts dotenv @nomiclabs/hardhat-ethers ethers\n    ```\n\n3. **Set Up Omnichain Testnet**:\n    - Obtain testnet funds for deploying contracts.\n    - Configure your wallet and RPC provider.\n\n\n### Smart Contract Implementation\n\nHere’s a Solidity contract for tokenized real estate:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TokenizedRealEstate is ERC721, Ownable {\n    uint256 public nextTokenId;\n    mapping(uint256 => string) private _propertyDetails;\n\n    constructor() ERC721(\"OmnichainRealEstate\", \"ORE\") {}\n\n    function mintProperty(address to, string memory propertyDetails) public onlyOwner {\n        uint256 tokenId = nextTokenId;\n        _safeMint(to, tokenId);\n        _propertyDetails[tokenId] = propertyDetails;\n        nextTokenId++;\n    }\n\n    function getPropertyDetails(uint256 tokenId) public view returns (string memory) {\n        require(_exists(tokenId), \"Token ID does not exist\");\n        return _propertyDetails[tokenId];\n    }\n}\n```\n\n### Hardhat Configuration\n\nUpdate `hardhat.config.js` to include Omnichain settings:\n\n```javascript\nrequire(\"@nomiclabs/hardhat-ethers\");\nrequire(\"dotenv\").config();\n\nmodule.exports = {\n  solidity: \"0.8.0\",\n  networks: {\n    omnichainTestnet: {\n      url: process.env.OMNICHAIN_RPC_URL,\n      accounts: [process.env.PRIVATE_KEY],\n    },\n  },\n};\n```\n\nCreate a `.env` file to store sensitive information:\n\n```plaintext\nOMNICHAIN_RPC_URL=<Your Omnichain RPC URL>\nPRIVATE_KEY=<Your Private Key>\n```\n\n### Deploy the Contract\n\nCreate a `scripts/deploy.js` file:\n\n```javascript\nasync function main() {\n  const [deployer] = await ethers.getSigners();\n  console.log(\"Deploying contracts with the account:\", deployer.address);\n\n  const RealEstate = await ethers.getContractFactory(\"TokenizedRealEstate\");\n  const realEstate = await RealEstate.deploy();\n\n  await realEstate.deployed();\n  console.log(\"TokenizedRealEstate deployed to:\", realEstate.address);\n}\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error);\n    process.exit(1);\n  });\n```\n\nRun the deployment script:\n\n```bash\nnpx hardhat run scripts/deploy.js --network omnichainTestnet\n```\n\n### Testing the Contract\n\nInteract with the deployed contract using Hardhat console:\n\n```bash\nnpx hardhat console --network omnichainTestnet\n```\n\nExample interactions:\n\n```javascript\nconst contract = await ethers.getContractAt(\"TokenizedRealEstate\", \"<Deployed_Address>\");\n\n// Mint a property\nawait contract.mintProperty(\"0xRecipientAddress\", \"Property at 123 Blockchain Lane\");\n\n// Retrieve property details\nconst details = await contract.getPropertyDetails(0);\nconsole.log(details);\n```\n\n### Summary\n\nYou’ve successfully created and deployed a tokenized real estate contract on Omnichain. This framework can be extended with features like payment integration, fractional ownership, or governance mechanisms.\n",
    "preview": "\n# Your First Smart Contract\n\nTokenizing real estate on the Omnichain blockchain allows fractional ownership, seamless transfer of assets, and improved transparency. In this guide, we'll create a smar..."
  },
  {
    "title": "get-omni",
    "url": "/tutorial-basics/get-omni",
    "content": "\n# Get Omni\n\n## Oasis Testnet and Faucet <a id=\"oasis-testnet-and-faucet\"></a>\n\nThe **testnet OMNI** faucet runs on the Kairos network. The faucet can be accessed from the [Oasis Omni Faucet](https://faucet.Omni.io). To receive testnet OMNI, you should have a valid OMNI account.\n\n* Load your account into the wallet using your private key or keystore file. Testnet KAIA will be sent to the loaded account. \n* Clicking `Run Faucet` button will send you 50 testnet KAIA and update your balance. Note that you can run the faucet for each account once every 24 hours.\n\n## OMNI Exchange List <a id=\"kaia-exchange-list\"></a>\n\nKAIA is listed on various exchanges.  Please find the list of KAIA exchanges through the following links.\n\n- [OMNI exchanges listed at CoinGecko](https://www.coingecko.com/en/coins/omni#markets)\n- [OMNI exchanges listed at CoinMarketCap](https://coinmarketcap.com/currencies/omni/markets/)\n\n",
    "preview": "\n# Get Omni\n\n## Oasis Testnet and Faucet <a id=\"oasis-testnet-and-faucet\"></a>\n\nThe **testnet OMNI** faucet runs on the Kairos network. The faucet can be accessed from the [Oasis Omni Faucet](https://..."
  },
  {
    "title": "housekeeping",
    "url": "/tutorial-basics/housekeeping",
    "content": "\n\n# Housekeeping  \nBefore diving into OmnichainL2, here’s some essential information to get you started.  \n\n\n### OmnichainL2 Network \n\nOmnichainL2 operates on the following environments:  \n\n- **Oasis Testnet**  \n  For testing and experimenting without real-world consequences.  \n- **Mainnet**  \n  The live environment where actual transactions and applications operate.  \n\n\n### Endpoint Node\n\nTo interact with the OmnichainL2 network, you’ll need an **Endpoint Node**. This node acts as your gateway to the network for making API calls or submitting transactions.  \n\n- **`oln`** is the OmnichainL2 Endpoint Node binary. It exposes two interfaces:  \n  - A **[command-line interface (CLI)](../../nodes/endpoint-node/oln-cli-commands.md)** for node management and utility functions.  \n  - The **[JSON-RPC APIs](../../../references/json-rpc/ol2/transaction-guide.md)** for programmatic interactions.  \n- Compatible with Linux and macOS.  \n- The `oln` CLI provides powerful tools for managing nodes and executing network tasks.  \n\n### Smart Contract Development \n\nOmnichainL2 supports various tools for developing smart contracts and decentralized applications (dApps):  \n\n- **[Omnichain Plugin for Remix](https://ide.omnichainl2.io)**  \n  A browser-based compiler and IDE tailored for OmnichainL2 smart contract development.  \n- **[Truffle](https://github.com/trufflesuite/truffle)**  \n  An open-source development framework for Solidity-based projects.  \n- **[Hardhat](https://hardhat.org/hardhat-runner/docs/getting-started)**  \n  A comprehensive environment for building and testing smart contracts.  \n- **[Foundry](https://book.getfoundry.sh/)**  \n  A modern, fast toolchain for developing, testing, and deploying smart contracts.  \n- **[Thirdweb](https://portal.thirdweb.com/)**  \n  A complete framework to build, manage, and analyze your Web3 applications.  \n\n### OmnichainL2 SDKs  \n\nSDKs allow developers to easily interact with the OmnichainL2 network:  \n\n- **[ol2-js](../../references/sdk/ol2-js/ol2-js.md)**  \n  A JavaScript library that provides access to OmnichainL2 JSON-RPC APIs.  \n- **[ol2-java](../../references/sdk/ol2-java/ol2-java.md)**  \n  A Java library for seamless integration with the OmnichainL2 network.  \n\n\n### OmnichainL2 Toolkits \n\nThese tools help you explore, manage, and build on OmnichainL2:  \n\n- **[Omniscan](https://omniscan.com/)**  \n  A block and transaction explorer to track network activity.  \n- **[Omnichain Wallet](https://www.omnichainwallet.io/)**  \n  A browser extension wallet designed for the OmnichainL2 ecosystem.  \n- **[Omnichain Contracts Wizard](https://wizard.omnichainl2.foundation/)**  \n  An interactive tool to bootstrap your smart contracts and learn the basics of OmnichainL2 development.  \n\n\nThis guide provides the foundational tools and resources you need to start building on OmnichainL2. Explore, experiment, and bring your ideas to life on a secure and scalable blockchain!\n",
    "preview": "\n\n# Housekeeping  \nBefore diving into OmnichainL2, here’s some essential information to get you started.  \n\n\n### OmnichainL2 Network \n\nOmnichainL2 operates on the following environments:  \n\n- **Oasis ..."
  },
  {
    "title": "markdown-features",
    "url": "/tutorial-basics/markdown-features",
    "content": "\n# Markdown Features\n\nDocusaurus supports **[Markdown](https://daringfireball.net/projects/markdown/syntax)** and a few **additional features**.\n\n## Front Matter\n\nMarkdown documents have metadata at the top called [Front Matter](https://jekyllrb.com/docs/front-matter/):\n\n```text title=\"my-doc.md\"\n// highlight-start\n---\nid: my-doc-id\ntitle: My document title\ndescription: My document description\nslug: /my-custom-url\n---\n// highlight-end\n\n## Markdown heading\n\nMarkdown text with [links](./hello.md)\n```\n\n## Links\n\nRegular Markdown links are supported, using url paths or relative file paths.\n\n```md\nLet's see how to [Create a page](/create-a-page).\n```\n\n```md\nLet's see how to [Create a page](./create-a-page.md).\n```\n\n**Result:** Let's see how to [Create a page](./create-a-page.md).\n\n## Images\n\nRegular Markdown images are supported.\n\nYou can use absolute paths to reference images in the static directory (`static/img/docusaurus.png`):\n\n```md\n![Docusaurus logo](/img/docusaurus.png)\n```\n\n![Docusaurus logo](/img/docusaurus.png)\n\nYou can reference images relative to the current file as well. This is particularly useful to colocate images close to the Markdown files using them:\n\n```md\n![Docusaurus logo](./img/docusaurus.png)\n```\n\n## Code Blocks\n\nMarkdown code blocks are supported with Syntax highlighting.\n\n````md\n```jsx title=\"src/components/HelloDocusaurus.js\"\nfunction HelloDocusaurus() {\n  return <h1>Hello, Docusaurus!</h1>;\n}\n```\n````\n\n```jsx title=\"src/components/HelloDocusaurus.js\"\nfunction HelloDocusaurus() {\n  return <h1>Hello, Docusaurus!</h1>;\n}\n```\n\n## Admonitions\n\nDocusaurus has a special syntax to create admonitions and callouts:\n\n```md\n:::tip My tip\n\nUse this awesome feature option\n\n:::\n\n:::danger Take care\n\nThis action is dangerous\n\n:::\n```\n\n:::tip My tip\n\nUse this awesome feature option\n\n:::\n\n:::danger Take care\n\nThis action is dangerous\n\n:::\n\n## MDX and React Components\n\n[MDX](https://mdxjs.com/) can make your documentation more **interactive** and allows using any **React components inside Markdown**:\n\n```jsx\nexport const Highlight = ({children, color}) => (\n  <span\n    style={{\n      backgroundColor: color,\n      borderRadius: '20px',\n      color: '#fff',\n      padding: '10px',\n      cursor: 'pointer',\n    }}\n    onClick={() => {\n      alert(`You clicked the color ${color} with label ${children}`)\n    }}>\n    {children}\n  </span>\n);\n\nThis is <Highlight color=\"#25c2a0\">Docusaurus green</Highlight> !\n\nThis is <Highlight color=\"#1877F2\">Facebook blue</Highlight> !\n```\n\nexport const Highlight = ({children, color}) => (\n  <span\n    style={{\n      backgroundColor: color,\n      borderRadius: '20px',\n      color: '#fff',\n      padding: '10px',\n      cursor: 'pointer',\n    }}\n    onClick={() => {\n      alert(`You clicked the color ${color} with label ${children}`);\n    }}>\n    {children}\n  </span>\n);\n\nThis is <Highlight color=\"#25c2a0\">Docusaurus green</Highlight> !\n\nThis is <Highlight color=\"#1877F2\">Facebook blue</Highlight> !\n",
    "preview": "\n# Markdown Features\n\nDocusaurus supports **[Markdown](https://daringfireball.net/projects/markdown/syntax)** and a few **additional features**.\n\n## Front Matter\n\nMarkdown documents have metadata at t..."
  },
  {
    "title": "what-is-omni",
    "url": "/tutorial-basics/what-is-omni",
    "content": "\n# What is OmniL2?  \n\nA high-level overview of what Abstract is and how it works.  \n\nAbstract is a Layer 2 (L2) network built on top of Ethereum, designed to securely power consumer-facing blockchain applications at scale with low fees and fast transaction speeds.  \n\nBuilt on top of the ZK Stack, Abstract is a zero-knowledge (ZK) rollup built to be a more scalable alternative to Ethereum; it achieves this scalability by executing transactions off-chain, batching them together, and verifying batches of transactions on Ethereum using ZK proofs.  \n\nAbstract is EVM compatible, meaning it looks and feels like Ethereum, but with lower gas fees and higher transaction throughput. Most existing smart contracts built for Ethereum will work out of the box on Abstract (with some differences), meaning developers can easily port applications to Abstract with minimal changes.  \n\n## Start using Abstract  \n\nReady to start building on Abstract? Here are some next steps to get you started:  ",
    "preview": "\n# What is OmniL2?  \n\nA high-level overview of what Abstract is and how it works.  \n\nAbstract is a Layer 2 (L2) network built on top of Ethereum, designed to securely power consumer-facing blockchain ..."
  },
  {
    "title": "manage-docs-versions",
    "url": "/tutorial-extras/manage-docs-versions",
    "content": "\n# Manage Docs Versions\n\nDocusaurus can manage multiple versions of your docs.\n\n## Create a docs version\n\nRelease a version 1.0 of your project:\n\n```bash\nnpm run docusaurus docs:version 1.0\n```\n\nThe `docs` folder is copied into `versioned_docs/version-1.0` and `versions.json` is created.\n\nYour docs now have 2 versions:\n\n- `1.0` at `http://localhost:3000/docs/` for the version 1.0 docs\n- `current` at `http://localhost:3000/docs/next/` for the **upcoming, unreleased docs**\n\n## Add a Version Dropdown\n\nTo navigate seamlessly across versions, add a version dropdown.\n\nModify the `docusaurus.config.js` file:\n\n```js title=\"docusaurus.config.js\"\nexport default {\n  themeConfig: {\n    navbar: {\n      items: [\n        // highlight-start\n        {\n          type: 'docsVersionDropdown',\n        },\n        // highlight-end\n      ],\n    },\n  },\n};\n```\n\nThe docs version dropdown appears in your navbar:\n\n![Docs Version Dropdown](./img/docsVersionDropdown.png)\n\n## Update an existing version\n\nIt is possible to edit versioned docs in their respective folder:\n\n- `versioned_docs/version-1.0/hello.md` updates `http://localhost:3000/docs/hello`\n- `docs/hello.md` updates `http://localhost:3000/docs/next/hello`\n",
    "preview": "\n# Manage Docs Versions\n\nDocusaurus can manage multiple versions of your docs.\n\n## Create a docs version\n\nRelease a version 1.0 of your project:\n\n```bash\nnpm run docusaurus docs:version 1.0\n```\n\nThe `..."
  },
  {
    "title": "translate-your-site",
    "url": "/tutorial-extras/translate-your-site",
    "content": "\n# Translate your site\n\nLet's translate `docs/intro.md` to French.\n\n## Configure i18n\n\nModify `docusaurus.config.js` to add support for the `fr` locale:\n\n```js title=\"docusaurus.config.js\"\nexport default {\n  i18n: {\n    defaultLocale: 'en',\n    locales: ['en', 'fr'],\n  },\n};\n```\n\n## Translate a doc\n\nCopy the `docs/intro.md` file to the `i18n/fr` folder:\n\n```bash\nmkdir -p i18n/fr/docusaurus-plugin-content-docs/current/\n\ncp docs/intro.md i18n/fr/docusaurus-plugin-content-docs/current/intro.md\n```\n\nTranslate `i18n/fr/docusaurus-plugin-content-docs/current/intro.md` in French.\n\n## Start your localized site\n\nStart your site on the French locale:\n\n```bash\nnpm run start -- --locale fr\n```\n\nYour localized site is accessible at [http://localhost:3000/fr/](http://localhost:3000/fr/) and the `Getting Started` page is translated.\n\n:::caution\n\nIn development, you can only use one locale at a time.\n\n:::\n\n## Add a Locale Dropdown\n\nTo navigate seamlessly across languages, add a locale dropdown.\n\nModify the `docusaurus.config.js` file:\n\n```js title=\"docusaurus.config.js\"\nexport default {\n  themeConfig: {\n    navbar: {\n      items: [\n        // highlight-start\n        {\n          type: 'localeDropdown',\n        },\n        // highlight-end\n      ],\n    },\n  },\n};\n```\n\nThe locale dropdown now appears in your navbar:\n\n![Locale Dropdown](./img/localeDropdown.png)\n\n## Build your localized site\n\nBuild your site for a specific locale:\n\n```bash\nnpm run build -- --locale fr\n```\n\nOr build your site to include all the locales at once:\n\n```bash\nnpm run build\n```\n",
    "preview": "\n# Translate your site\n\nLet's translate `docs/intro.md` to French.\n\n## Configure i18n\n\nModify `docusaurus.config.js` to add support for the `fr` locale:\n\n```js title=\"docusaurus.config.js\"\nexport defa..."
  }
]